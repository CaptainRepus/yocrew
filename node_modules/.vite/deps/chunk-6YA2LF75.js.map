{
  "version": 3,
  "sources": ["../../@ionic/core/components/cubic-bezier.js", "../../@ionic/core/components/config.js", "../../@ionic/core/components/theme.js", "../../@ionic/core/components/index4.js", "../../@ionic/core/components/framework-delegate.js", "../../@ionic/core/components/overlays.js", "../../@ionic/core/components/index.js"],
  "sourcesContent": ["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Based on:\n * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier\n * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves\n */\n/**\n * EXPERIMENTAL\n * Given a cubic-bezier curve, get the x value (time) given\n * the y value (progression).\n * Ex: cubic-bezier(0.32, 0.72, 0, 1);\n * P0: (0, 0)\n * P1: (0.32, 0.72)\n * P2: (0, 1)\n * P3: (1, 1)\n *\n * If you give a cubic bezier curve that never reaches the\n * provided progression, this function will return an empty array.\n */\nconst getTimeGivenProgression = (p0, p1, p2, p3, progression) => {\n    return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map((tValue) => {\n        return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);\n    });\n};\n/**\n * Solve a cubic equation in one dimension (time)\n */\nconst solveCubicParametricEquation = (p0, p1, p2, p3, t) => {\n    const partA = 3 * p1 * Math.pow(t - 1, 2);\n    const partB = -3 * p2 * t + 3 * p2 + p3 * t;\n    const partC = p0 * Math.pow(t - 1, 3);\n    return t * (partA + t * partB) - partC;\n};\n/**\n * Find the `t` value for a cubic bezier using Cardano's formula\n */\nconst solveCubicBezier = (p0, p1, p2, p3, refPoint) => {\n    p0 -= refPoint;\n    p1 -= refPoint;\n    p2 -= refPoint;\n    p3 -= refPoint;\n    const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);\n    return roots.filter((root) => root >= 0 && root <= 1);\n};\nconst solveQuadraticEquation = (a, b, c) => {\n    const discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return [];\n    }\n    else {\n        return [(-b + Math.sqrt(discriminant)) / (2 * a), (-b - Math.sqrt(discriminant)) / (2 * a)];\n    }\n};\nconst solveCubicEquation = (a, b, c, d) => {\n    if (a === 0) {\n        return solveQuadraticEquation(b, c, d);\n    }\n    b /= a;\n    c /= a;\n    d /= a;\n    const p = (3 * c - b * b) / 3;\n    const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;\n    if (p === 0) {\n        return [Math.pow(-q, 1 / 3)];\n    }\n    else if (q === 0) {\n        return [Math.sqrt(-p), -Math.sqrt(-p)];\n    }\n    const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);\n    if (discriminant === 0) {\n        return [Math.pow(q / 2, 1 / 2) - b / 3];\n    }\n    else if (discriminant > 0) {\n        return [\n            Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q / 2 + Math.sqrt(discriminant), 1 / 3) - b / 3,\n        ];\n    }\n    const r = Math.sqrt(Math.pow(-(p / 3), 3));\n    const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));\n    const s = 2 * Math.pow(r, 1 / 3);\n    return [\n        s * Math.cos(phi / 3) - b / 3,\n        s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3,\n        s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3,\n    ];\n};\n\nexport { getTimeGivenProgression as g };\n", "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\n/**\n * Does a simple sanitization of all elements\n * in an untrusted string\n */\nconst sanitizeDOMString = (untrustedString) => {\n    try {\n        if (untrustedString instanceof IonicSafeString) {\n            return untrustedString.value;\n        }\n        if (!isSanitizerEnabled() || typeof untrustedString !== 'string' || untrustedString === '') {\n            return untrustedString;\n        }\n        /**\n         * onload is fired when appending to a document\n         * fragment in Chrome. If a string\n         * contains onload then we should not\n         * attempt to add this to the fragment.\n         */\n        if (untrustedString.includes('onload=')) {\n            return '';\n        }\n        /**\n         * Create a document fragment\n         * separate from the main DOM,\n         * create a div to do our work in\n         */\n        const documentFragment = document.createDocumentFragment();\n        const workingDiv = document.createElement('div');\n        documentFragment.appendChild(workingDiv);\n        workingDiv.innerHTML = untrustedString;\n        /**\n         * Remove any elements\n         * that are blocked\n         */\n        blockedTags.forEach((blockedTag) => {\n            const getElementsToRemove = documentFragment.querySelectorAll(blockedTag);\n            for (let elementIndex = getElementsToRemove.length - 1; elementIndex >= 0; elementIndex--) {\n                const element = getElementsToRemove[elementIndex];\n                if (element.parentNode) {\n                    element.parentNode.removeChild(element);\n                }\n                else {\n                    documentFragment.removeChild(element);\n                }\n                /**\n                 * We still need to sanitize\n                 * the children of this element\n                 * as they are left behind\n                 */\n                const childElements = getElementChildren(element);\n                /* eslint-disable-next-line */\n                for (let childIndex = 0; childIndex < childElements.length; childIndex++) {\n                    sanitizeElement(childElements[childIndex]);\n                }\n            }\n        });\n        /**\n         * Go through remaining elements and remove\n         * non-allowed attribs\n         */\n        // IE does not support .children on document fragments, only .childNodes\n        const dfChildren = getElementChildren(documentFragment);\n        /* eslint-disable-next-line */\n        for (let childIndex = 0; childIndex < dfChildren.length; childIndex++) {\n            sanitizeElement(dfChildren[childIndex]);\n        }\n        // Append document fragment to div\n        const fragmentDiv = document.createElement('div');\n        fragmentDiv.appendChild(documentFragment);\n        // First child is always the div we did our work in\n        const getInnerDiv = fragmentDiv.querySelector('div');\n        return getInnerDiv !== null ? getInnerDiv.innerHTML : fragmentDiv.innerHTML;\n    }\n    catch (err) {\n        console.error(err);\n        return '';\n    }\n};\n/**\n * Clean up current element based on allowed attributes\n * and then recursively dig down into any child elements to\n * clean those up as well\n */\n// TODO(FW-2832): type (using Element triggers other type errors as well)\nconst sanitizeElement = (element) => {\n    // IE uses childNodes, so ignore nodes that are not elements\n    if (element.nodeType && element.nodeType !== 1) {\n        return;\n    }\n    /**\n     * If attributes is not a NamedNodeMap\n     * then we should remove the element entirely.\n     * This helps avoid DOM Clobbering attacks where\n     * attributes is overridden.\n     */\n    if (typeof NamedNodeMap !== 'undefined' && !(element.attributes instanceof NamedNodeMap)) {\n        element.remove();\n        return;\n    }\n    for (let i = element.attributes.length - 1; i >= 0; i--) {\n        const attribute = element.attributes.item(i);\n        const attributeName = attribute.name;\n        // remove non-allowed attribs\n        if (!allowedAttributes.includes(attributeName.toLowerCase())) {\n            element.removeAttribute(attributeName);\n            continue;\n        }\n        // clean up any allowed attribs\n        // that attempt to do any JS funny-business\n        const attributeValue = attribute.value;\n        /**\n         * We also need to check the property value\n         * as javascript: can allow special characters\n         * such as &Tab; and still be valid (i.e. java&Tab;script)\n         */\n        const propertyValue = element[attributeName];\n        /* eslint-disable */\n        if ((attributeValue != null && attributeValue.toLowerCase().includes('javascript:')) ||\n            (propertyValue != null && propertyValue.toLowerCase().includes('javascript:'))) {\n            element.removeAttribute(attributeName);\n        }\n        /* eslint-enable */\n    }\n    /**\n     * Sanitize any nested children\n     */\n    const childElements = getElementChildren(element);\n    /* eslint-disable-next-line */\n    for (let i = 0; i < childElements.length; i++) {\n        sanitizeElement(childElements[i]);\n    }\n};\n/**\n * IE doesn't always support .children\n * so we revert to .childNodes instead\n */\n// TODO(FW-2832): type\nconst getElementChildren = (el) => {\n    return el.children != null ? el.children : el.childNodes;\n};\nconst isSanitizerEnabled = () => {\n    var _a;\n    const win = window;\n    const config = (_a = win === null || win === void 0 ? void 0 : win.Ionic) === null || _a === void 0 ? void 0 : _a.config;\n    if (config) {\n        if (config.get) {\n            return config.get('sanitizerEnabled', true);\n        }\n        else {\n            return config.sanitizerEnabled === true || config.sanitizerEnabled === undefined;\n        }\n    }\n    return true;\n};\nconst allowedAttributes = ['class', 'id', 'href', 'src', 'name', 'slot'];\nconst blockedTags = ['script', 'style', 'iframe', 'meta', 'link', 'object', 'embed'];\nclass IonicSafeString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n\nconst setupConfig = (config) => {\n    const win = window;\n    const Ionic = win.Ionic;\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (Ionic && Ionic.config && Ionic.config.constructor.name !== 'Object') {\n        return;\n    }\n    win.Ionic = win.Ionic || {};\n    win.Ionic.config = Object.assign(Object.assign({}, win.Ionic.config), config);\n    return win.Ionic.config;\n};\nconst getMode = () => {\n    var _a;\n    const win = window;\n    const config = (_a = win === null || win === void 0 ? void 0 : win.Ionic) === null || _a === void 0 ? void 0 : _a.config;\n    if (config) {\n        if (config.mode) {\n            return config.mode;\n        }\n        else {\n            return config.get('mode');\n        }\n    }\n    return 'md';\n};\nconst ENABLE_HTML_CONTENT_DEFAULT = false;\n\nexport { ENABLE_HTML_CONTENT_DEFAULT as E, IonicSafeString as I, sanitizeDOMString as a, getMode as g, setupConfig as s };\n", "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n    return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n    return typeof color === 'string' && color.length > 0\n        ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n    if (classes !== undefined) {\n        const array = Array.isArray(classes) ? classes : classes.split(' ');\n        return array\n            .filter((c) => c != null)\n            .map((c) => c.trim())\n            .filter((c) => c !== '');\n    }\n    return [];\n};\nconst getClassMap = (classes) => {\n    const map = {};\n    getClassList(classes).forEach((c) => (map[c] = true));\n    return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n        const router = document.querySelector('ion-router');\n        if (router) {\n            if (ev != null) {\n                ev.preventDefault();\n            }\n            return router.push(url, direction, animation);\n        }\n    }\n    return false;\n};\n\nexport { createColorClasses as c, getClassMap as g, hostContext as h, openURL as o };\n", "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index5.js';\nimport { MENU_BACK_BUTTON_PRIORITY } from './hardware-back-button.js';\nimport { p as printIonWarning } from './index6.js';\nimport { c as componentOnReady } from './helpers.js';\nimport { b as getIonMode } from './ionic-global.js';\nimport { c as createAnimation } from './animation.js';\n\n/**\n * baseAnimation\n * Base class which is extended by the various types. Each\n * type will provide their own animations for open and close\n * and registers itself with Menu.\n */\nconst baseAnimation = (isIos) => {\n    // https://material.io/guidelines/motion/movement.html#movement-movement-in-out-of-screen-bounds\n    // https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves\n    /**\n     * \"Apply the sharp curve to items temporarily leaving the screen that may return\n     * from the same exit point. When they return, use the deceleration curve. On mobile,\n     * this transition typically occurs over 300ms\" -- MD Motion Guide\n     */\n    return createAnimation().duration(isIos ? 400 : 300);\n};\n\n/**\n * Menu Overlay Type\n * The menu slides over the content. The content\n * itself, which is under the menu, does not move.\n */\nconst menuOverlayAnimation = (menu) => {\n    let closedX;\n    let openedX;\n    const width = menu.width + 8;\n    const menuAnimation = createAnimation();\n    const backdropAnimation = createAnimation();\n    if (menu.isEndSide) {\n        // right side\n        closedX = width + 'px';\n        openedX = '0px';\n    }\n    else {\n        // left side\n        closedX = -width + 'px';\n        openedX = '0px';\n    }\n    menuAnimation.addElement(menu.menuInnerEl).fromTo('transform', `translateX(${closedX})`, `translateX(${openedX})`);\n    const mode = getIonMode(menu);\n    const isIos = mode === 'ios';\n    const opacity = isIos ? 0.2 : 0.25;\n    backdropAnimation.addElement(menu.backdropEl).fromTo('opacity', 0.01, opacity);\n    return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Push Type\n * The content slides over to reveal the menu underneath.\n * The menu itself also slides over to reveal its bad self.\n */\nconst menuPushAnimation = (menu) => {\n    let contentOpenedX;\n    let menuClosedX;\n    const mode = getIonMode(menu);\n    const width = menu.width;\n    if (menu.isEndSide) {\n        contentOpenedX = -width + 'px';\n        menuClosedX = width + 'px';\n    }\n    else {\n        contentOpenedX = width + 'px';\n        menuClosedX = -width + 'px';\n    }\n    const menuAnimation = createAnimation()\n        .addElement(menu.menuInnerEl)\n        .fromTo('transform', `translateX(${menuClosedX})`, 'translateX(0px)');\n    const contentAnimation = createAnimation()\n        .addElement(menu.contentEl)\n        .fromTo('transform', 'translateX(0px)', `translateX(${contentOpenedX})`);\n    const backdropAnimation = createAnimation().addElement(menu.backdropEl).fromTo('opacity', 0.01, 0.32);\n    return baseAnimation(mode === 'ios').addAnimation([menuAnimation, contentAnimation, backdropAnimation]);\n};\n\n/**\n * Menu Reveal Type\n * The content slides over to reveal the menu underneath.\n * The menu itself, which is under the content, does not move.\n */\nconst menuRevealAnimation = (menu) => {\n    const mode = getIonMode(menu);\n    const openedX = menu.width * (menu.isEndSide ? -1 : 1) + 'px';\n    const contentOpen = createAnimation()\n        .addElement(menu.contentEl) // REVIEW\n        .fromTo('transform', 'translateX(0px)', `translateX(${openedX})`);\n    return baseAnimation(mode === 'ios').addAnimation(contentOpen);\n};\n\nconst createMenuController = () => {\n    const menuAnimations = new Map();\n    const menus = [];\n    const open = async (menu) => {\n        const menuEl = await get(menu, true);\n        if (menuEl) {\n            return menuEl.open();\n        }\n        return false;\n    };\n    const close = async (menu) => {\n        const menuEl = await (menu !== undefined ? get(menu, true) : getOpen());\n        if (menuEl !== undefined) {\n            return menuEl.close();\n        }\n        return false;\n    };\n    const toggle = async (menu) => {\n        const menuEl = await get(menu, true);\n        if (menuEl) {\n            return menuEl.toggle();\n        }\n        return false;\n    };\n    const enable = async (shouldEnable, menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            menuEl.disabled = !shouldEnable;\n        }\n        return menuEl;\n    };\n    const swipeGesture = async (shouldEnable, menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            menuEl.swipeGesture = shouldEnable;\n        }\n        return menuEl;\n    };\n    const isOpen = async (menu) => {\n        if (menu != null) {\n            const menuEl = await get(menu);\n            // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n            return menuEl !== undefined && menuEl.isOpen();\n        }\n        else {\n            const menuEl = await getOpen();\n            return menuEl !== undefined;\n        }\n    };\n    const isEnabled = async (menu) => {\n        const menuEl = await get(menu);\n        if (menuEl) {\n            return !menuEl.disabled;\n        }\n        return false;\n    };\n    /**\n     * Finds and returns the menu specified by \"menu\" if registered.\n     * @param menu - The side or ID of the desired menu\n     * @param logOnMultipleSideMenus - If true, this function will log a warning\n     * if \"menu\" is a side but multiple menus on the same side were found. Since this function\n     * is used in multiple places, we default this log to false so that the calling\n     * functions can choose whether or not it is appropriate to log this warning.\n     */\n    const get = async (menu, logOnMultipleSideMenus = false) => {\n        await waitUntilReady();\n        if (menu === 'start' || menu === 'end') {\n            // there could be more than one menu on the same side\n            // so first try to get the enabled one\n            const menuRefs = menus.filter((m) => m.side === menu && !m.disabled);\n            if (menuRefs.length >= 1) {\n                if (menuRefs.length > 1 && logOnMultipleSideMenus) {\n                    printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${menuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, menuRefs.map((m) => m.el));\n                }\n                return menuRefs[0].el;\n            }\n            // didn't find a menu side that is enabled\n            // so try to get the first menu side found\n            const sideMenuRefs = menus.filter((m) => m.side === menu);\n            if (sideMenuRefs.length >= 1) {\n                if (sideMenuRefs.length > 1 && logOnMultipleSideMenus) {\n                    printIonWarning(`menuController queried for a menu on the \"${menu}\" side, but ${sideMenuRefs.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`, sideMenuRefs.map((m) => m.el));\n                }\n                return sideMenuRefs[0].el;\n            }\n        }\n        else if (menu != null) {\n            // the menuId was not left or right\n            // so try to get the menu by its \"id\"\n            return find((m) => m.menuId === menu);\n        }\n        // return the first enabled menu\n        const menuEl = find((m) => !m.disabled);\n        if (menuEl) {\n            return menuEl;\n        }\n        // get the first menu in the array, if one exists\n        return menus.length > 0 ? menus[0].el : undefined;\n    };\n    /**\n     * Get the instance of the opened menu. Returns `null` if a menu is not found.\n     */\n    const getOpen = async () => {\n        await waitUntilReady();\n        return _getOpenSync();\n    };\n    /**\n     * Get all menu instances.\n     */\n    const getMenus = async () => {\n        await waitUntilReady();\n        return getMenusSync();\n    };\n    /**\n     * Get whether or not a menu is animating. Returns `true` if any\n     * menu is currently animating.\n     */\n    const isAnimating = async () => {\n        await waitUntilReady();\n        return isAnimatingSync();\n    };\n    const registerAnimation = (name, animation) => {\n        menuAnimations.set(name, animation);\n    };\n    const _register = (menu) => {\n        if (menus.indexOf(menu) < 0) {\n            menus.push(menu);\n        }\n    };\n    const _unregister = (menu) => {\n        const index = menus.indexOf(menu);\n        if (index > -1) {\n            menus.splice(index, 1);\n        }\n    };\n    const _setOpen = async (menu, shouldOpen, animated) => {\n        if (isAnimatingSync()) {\n            return false;\n        }\n        if (shouldOpen) {\n            const openedMenu = await getOpen();\n            if (openedMenu && menu.el !== openedMenu) {\n                await openedMenu.setOpen(false, false);\n            }\n        }\n        return menu._setOpen(shouldOpen, animated);\n    };\n    const _createAnimation = (type, menuCmp) => {\n        const animationBuilder = menuAnimations.get(type); // TODO(FW-2832): type\n        if (!animationBuilder) {\n            throw new Error('animation not registered');\n        }\n        const animation = animationBuilder(menuCmp);\n        return animation;\n    };\n    const _getOpenSync = () => {\n        return find((m) => m._isOpen);\n    };\n    const getMenusSync = () => {\n        return menus.map((menu) => menu.el);\n    };\n    const isAnimatingSync = () => {\n        return menus.some((menu) => menu.isAnimating);\n    };\n    const find = (predicate) => {\n        const instance = menus.find(predicate);\n        if (instance !== undefined) {\n            return instance.el;\n        }\n        return undefined;\n    };\n    const waitUntilReady = () => {\n        return Promise.all(Array.from(document.querySelectorAll('ion-menu')).map((menu) => new Promise((resolve) => componentOnReady(menu, resolve))));\n    };\n    registerAnimation('reveal', menuRevealAnimation);\n    registerAnimation('push', menuPushAnimation);\n    registerAnimation('overlay', menuOverlayAnimation);\n    doc === null || doc === void 0 ? void 0 : doc.addEventListener('ionBackButton', (ev) => {\n        const openMenu = _getOpenSync();\n        if (openMenu) {\n            ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {\n                return openMenu.close();\n            });\n        }\n    });\n    return {\n        registerAnimation,\n        get,\n        getMenus,\n        getOpen,\n        isEnabled,\n        swipeGesture,\n        isAnimating,\n        isOpen,\n        enable,\n        toggle,\n        close,\n        open,\n        _getOpenSync,\n        _createAnimation,\n        _register,\n        _unregister,\n        _setOpen,\n    };\n};\nconst menuController = /*@__PURE__*/ createMenuController();\n\nexport { menuController as m };\n", "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers.js';\n\n// TODO(FW-2832): types\nconst attachComponent = async (delegate, container, component, cssClasses, componentProps, inline) => {\n    var _a;\n    if (delegate) {\n        return delegate.attachViewToDom(container, component, componentProps, cssClasses);\n    }\n    if (!inline && typeof component !== 'string' && !(component instanceof HTMLElement)) {\n        throw new Error('framework delegate is missing');\n    }\n    const el = typeof component === 'string' ? (_a = container.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(component) : component;\n    if (cssClasses) {\n        cssClasses.forEach((c) => el.classList.add(c));\n    }\n    if (componentProps) {\n        Object.assign(el, componentProps);\n    }\n    container.appendChild(el);\n    await new Promise((resolve) => componentOnReady(el, resolve));\n    return el;\n};\nconst detachComponent = (delegate, element) => {\n    if (element) {\n        if (delegate) {\n            const container = element.parentElement;\n            return delegate.removeViewFromDom(container, element);\n        }\n        element.remove();\n    }\n    return Promise.resolve();\n};\nconst CoreDelegate = () => {\n    let BaseComponent;\n    let Reference;\n    const attachViewToDom = async (parentElement, userComponent, userComponentProps = {}, cssClasses = []) => {\n        var _a, _b;\n        BaseComponent = parentElement;\n        let ChildComponent;\n        /**\n         * If passing in a component via the `component` props\n         * we need to append it inside of our overlay component.\n         */\n        if (userComponent) {\n            /**\n             * If passing in the tag name, create\n             * the element otherwise just get a reference\n             * to the component.\n             */\n            const el = typeof userComponent === 'string' ? (_a = BaseComponent.ownerDocument) === null || _a === void 0 ? void 0 : _a.createElement(userComponent) : userComponent;\n            /**\n             * Add any css classes passed in\n             * via the cssClasses prop on the overlay.\n             */\n            cssClasses.forEach((c) => el.classList.add(c));\n            /**\n             * Add any props passed in\n             * via the componentProps prop on the overlay.\n             */\n            Object.assign(el, userComponentProps);\n            /**\n             * Finally, append the component\n             * inside of the overlay component.\n             */\n            BaseComponent.appendChild(el);\n            ChildComponent = el;\n            await new Promise((resolve) => componentOnReady(el, resolve));\n        }\n        else if (BaseComponent.children.length > 0 &&\n            (BaseComponent.tagName === 'ION-MODAL' || BaseComponent.tagName === 'ION-POPOVER')) {\n            /**\n             * The delegate host wrapper el is only needed for modals and popovers\n             * because they allow the dev to provide custom content to the overlay.\n             */\n            const root = (ChildComponent = BaseComponent.children[0]);\n            if (!root.classList.contains('ion-delegate-host')) {\n                /**\n                 * If the root element is not a delegate host, it means\n                 * that the overlay has not been presented yet and we need\n                 * to create the containing element with the specified classes.\n                 */\n                const el = (_b = BaseComponent.ownerDocument) === null || _b === void 0 ? void 0 : _b.createElement('div');\n                // Add a class to track if the root element was created by the delegate.\n                el.classList.add('ion-delegate-host');\n                cssClasses.forEach((c) => el.classList.add(c));\n                // Move each child from the original template to the new parent element.\n                el.append(...BaseComponent.children);\n                // Append the new parent element to the original parent element.\n                BaseComponent.appendChild(el);\n                /**\n                 * Update the ChildComponent to be the\n                 * newly created div in the event that one\n                 * does not already exist.\n                 */\n                ChildComponent = el;\n            }\n        }\n        /**\n         * Get the root of the app and\n         * add the overlay there.\n         */\n        const app = document.querySelector('ion-app') || document.body;\n        /**\n         * Create a placeholder comment so that\n         * we can return this component to where\n         * it was previously.\n         */\n        Reference = document.createComment('ionic teleport');\n        BaseComponent.parentNode.insertBefore(Reference, BaseComponent);\n        app.appendChild(BaseComponent);\n        /**\n         * We return the child component rather than the overlay\n         * reference itself since modal and popover will\n         * use this to wait for any Ionic components in the child view\n         * to be ready (i.e. componentOnReady) when using the\n         * lazy loaded component bundle.\n         *\n         * However, we fall back to returning BaseComponent\n         * in the event that a modal or popover is presented\n         * with no child content.\n         */\n        return ChildComponent !== null && ChildComponent !== void 0 ? ChildComponent : BaseComponent;\n    };\n    const removeViewFromDom = () => {\n        /**\n         * Return component to where it was previously in the DOM.\n         */\n        if (BaseComponent && Reference) {\n            Reference.parentNode.insertBefore(BaseComponent, Reference);\n            Reference.remove();\n        }\n        return Promise.resolve();\n    };\n    return { attachViewToDom, removeViewFromDom };\n};\n\nexport { CoreDelegate as C, attachComponent as a, detachComponent as d };\n", "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { d as doc } from './index5.js';\nimport { f as focusVisibleElement, c as componentOnReady, a as addEventListener, b as removeEventListener, g as getElementRoot } from './helpers.js';\nimport { OVERLAY_BACK_BUTTON_PRIORITY, shouldUseCloseWatcher } from './hardware-back-button.js';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { C as CoreDelegate } from './framework-delegate.js';\nimport { B as BACKDROP_NO_SCROLL } from './gesture-controller.js';\nimport { p as printIonWarning } from './index6.js';\n\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\n/**\n * Focuses the first descendant in a context\n * that can receive focus. If none exists,\n * a fallback element will be focused.\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n *\n * If no fallback is specified then we focus the container itself.\n */\nconst focusFirstDescendant = (ref, fallbackElement) => {\n    const firstInput = ref.querySelector(focusableQueryString);\n    focusElementInContext(firstInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);\n};\n/**\n * Focuses the last descendant in a context\n * that can receive focus. If none exists,\n * a fallback element will be focused.\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n *\n * If no fallback is specified then we focus the container itself.\n */\nconst focusLastDescendant = (ref, fallbackElement) => {\n    const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n    const lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n    focusElementInContext(lastInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);\n};\n/**\n * Focuses a particular element in a context. If the element\n * doesn't have anything focusable associated with it then\n * a fallback element will be focused.\n *\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInContext = (hostToFocus, fallbackElement) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus fallback element instead of letting focus escape\n        fallbackElement.focus();\n    }\n};\n\nlet lastOverlayIndex = 0;\nlet lastId = 0;\nconst activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n    return {\n        create(options) {\n            return createOverlay(tagName, options);\n        },\n        dismiss(data, role, id) {\n            return dismissOverlay(document, data, role, tagName, id);\n        },\n        async getTop() {\n            return getPresentedOverlay(document, tagName);\n        },\n    };\n};\nconst alertController = /*@__PURE__*/ createController('ion-alert');\nconst actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nconst loadingController = /*@__PURE__*/ createController('ion-loading');\nconst modalController = /*@__PURE__*/ createController('ion-modal');\n/**\n * @deprecated Use the inline ion-picker component instead.\n */\nconst pickerController = /*@__PURE__*/ createController('ion-picker-legacy');\nconst popoverController = /*@__PURE__*/ createController('ion-popover');\nconst toastController = /*@__PURE__*/ createController('ion-toast');\n/**\n * Prepares the overlay element to be presented.\n */\nconst prepareOverlay = (el) => {\n    if (typeof document !== 'undefined') {\n        /**\n         * Adds a single instance of event listeners for application behaviors:\n         *\n         * - Escape Key behavior to dismiss an overlay\n         * - Trapping focus within an overlay\n         * - Back button behavior to dismiss an overlay\n         *\n         * This only occurs when the first overlay is created.\n         */\n        connectListeners(document);\n    }\n    const overlayIndex = lastOverlayIndex++;\n    /**\n     * overlayIndex is used in the overlay components to set a zIndex.\n     * This ensures that the most recently presented overlay will be\n     * on top.\n     */\n    el.overlayIndex = overlayIndex;\n};\n/**\n * Assigns an incrementing id to an overlay element, that does not\n * already have an id assigned to it.\n *\n * Used to track unique instances of an overlay element.\n */\nconst setOverlayId = (el) => {\n    if (!el.hasAttribute('id')) {\n        el.id = `ion-overlay-${++lastId}`;\n    }\n    return el.id;\n};\nconst createOverlay = (tagName, opts) => {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n        return window.customElements.whenDefined(tagName).then(() => {\n            const element = document.createElement(tagName);\n            element.classList.add('overlay-hidden');\n            /**\n             * Convert the passed in overlay options into props\n             * that get passed down into the new overlay.\n             */\n            Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n            // append the overlay element to the document body\n            getAppRoot(document).appendChild(element);\n            return new Promise((resolve) => componentOnReady(element, resolve));\n        });\n    }\n    return Promise.resolve();\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\n/**\n * Focuses a particular element in an overlay. If the element\n * doesn't have anything focusable associated with it then\n * the overlay itself will be focused.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInOverlay = (hostToFocus, overlay) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus overlay instead of letting focus escape\n        overlay.focus();\n    }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n    const lastOverlay = getPresentedOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover');\n    const target = ev.target;\n    /**\n     * If no active overlay, ignore this event.\n     *\n     * If this component uses the shadow dom,\n     * this global listener is pointless\n     * since it will not catch the focus\n     * traps as they are inside the shadow root.\n     * We need to add a listener to the shadow root\n     * itself to ensure the focus trap works.\n     */\n    if (!lastOverlay || !target) {\n        return;\n    }\n    /**\n     * If the ion-disable-focus-trap class\n     * is present on an overlay, then this component\n     * instance has opted out of focus trapping.\n     * An example of this is when the sheet modal\n     * has a backdrop that is disabled. The content\n     * behind the sheet should be focusable until\n     * the backdrop is enabled.\n     */\n    if (lastOverlay.classList.contains(FOCUS_TRAP_DISABLE_CLASS)) {\n        return;\n    }\n    const trapScopedFocus = () => {\n        /**\n         * If we are focusing the overlay, clear\n         * the last focused element so that hitting\n         * tab activates the first focusable element\n         * in the overlay wrapper.\n         */\n        if (lastOverlay === target) {\n            lastOverlay.lastFocus = undefined;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n            /**\n             * Otherwise, we must be focusing an element\n             * inside of the overlay. The two possible options\n             * here are an input/button/etc or the ion-focus-trap\n             * element. The focus trap element is used to prevent\n             * the keyboard focus from leaving the overlay when\n             * using Tab or screen assistants.\n             */\n        }\n        else {\n            /**\n             * We do not want to focus the traps, so get the overlay\n             * wrapper element as the traps live outside of the wrapper.\n             */\n            const overlayRoot = getElementRoot(lastOverlay);\n            if (!overlayRoot.contains(target)) {\n                return;\n            }\n            const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n            if (!overlayWrapper) {\n                return;\n            }\n            /**\n             * If the target is inside the wrapper, let the browser\n             * focus as normal and keep a log of the last focused element.\n             * Additionally, if the backdrop was tapped we should not\n             * move focus back inside the wrapper as that could cause\n             * an interactive elements focus state to activate.\n             */\n            if (overlayWrapper.contains(target) || target === overlayRoot.querySelector('ion-backdrop')) {\n                lastOverlay.lastFocus = target;\n            }\n            else {\n                /**\n                 * Otherwise, we must have focused one of the focus traps.\n                 * We need to wrap the focus to either the first element\n                 * or the last element.\n                 */\n                /**\n                 * Once we call `focusFirstDescendant` and focus the first\n                 * descendant, another focus event will fire which will\n                 * cause `lastOverlay.lastFocus` to be updated before\n                 * we can run the code after that. We will cache the value\n                 * here to avoid that.\n                 */\n                const lastFocus = lastOverlay.lastFocus;\n                // Focus the first element in the overlay wrapper\n                focusFirstDescendant(overlayWrapper, lastOverlay);\n                /**\n                 * If the cached last focused element is the\n                 * same as the active element, then we need\n                 * to wrap focus to the last descendant. This happens\n                 * when the first descendant is focused, and the user\n                 * presses Shift + Tab. The previous line will focus\n                 * the same descendant again (the first one), causing\n                 * last focus to equal the active element.\n                 */\n                if (lastFocus === doc.activeElement) {\n                    focusLastDescendant(overlayWrapper, lastOverlay);\n                }\n                lastOverlay.lastFocus = doc.activeElement;\n            }\n        }\n    };\n    const trapShadowFocus = () => {\n        /**\n         * If the target is inside the wrapper, let the browser\n         * focus as normal and keep a log of the last focused element.\n         */\n        if (lastOverlay.contains(target)) {\n            lastOverlay.lastFocus = target;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n        }\n        else {\n            /**\n             * Otherwise, we are about to have focus\n             * go out of the overlay. We need to wrap\n             * the focus to either the first element\n             * or the last element.\n             */\n            /**\n             * Once we call `focusFirstDescendant` and focus the first\n             * descendant, another focus event will fire which will\n             * cause `lastOverlay.lastFocus` to be updated before\n             * we can run the code after that. We will cache the value\n             * here to avoid that.\n             */\n            const lastFocus = lastOverlay.lastFocus;\n            // Focus the first element in the overlay wrapper\n            focusFirstDescendant(lastOverlay);\n            /**\n             * If the cached last focused element is the\n             * same as the active element, then we need\n             * to wrap focus to the last descendant. This happens\n             * when the first descendant is focused, and the user\n             * presses Shift + Tab. The previous line will focus\n             * the same descendant again (the first one), causing\n             * last focus to equal the active element.\n             */\n            if (lastFocus === doc.activeElement) {\n                focusLastDescendant(lastOverlay);\n            }\n            lastOverlay.lastFocus = doc.activeElement;\n        }\n    };\n    if (lastOverlay.shadowRoot) {\n        trapShadowFocus();\n    }\n    else {\n        trapScopedFocus();\n    }\n};\nconst connectListeners = (doc) => {\n    if (lastOverlayIndex === 0) {\n        lastOverlayIndex = 1;\n        doc.addEventListener('focus', (ev) => {\n            trapKeyboardFocus(ev, doc);\n        }, true);\n        // handle back-button click\n        doc.addEventListener('ionBackButton', (ev) => {\n            const lastOverlay = getPresentedOverlay(doc);\n            if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n                    /**\n                     * Do not return this promise otherwise\n                     * the hardware back button utility will\n                     * be blocked until the overlay dismisses.\n                     * This is important for a modal with canDismiss.\n                     * If the application presents a confirmation alert\n                     * in the \"canDismiss\" callback, then it will be impossible\n                     * to use the hardware back button to dismiss the alert\n                     * dialog because the hardware back button utility\n                     * is blocked on waiting for the modal to dismiss.\n                     */\n                    lastOverlay.dismiss(undefined, BACKDROP);\n                });\n            }\n        });\n        /**\n         * Handle ESC to close overlay.\n         * CloseWatcher also handles pressing the Esc\n         * key, so if a browser supports CloseWatcher then\n         * this behavior will be handled via the ionBackButton\n         * event.\n         */\n        if (!shouldUseCloseWatcher()) {\n            doc.addEventListener('keydown', (ev) => {\n                if (ev.key === 'Escape') {\n                    const lastOverlay = getPresentedOverlay(doc);\n                    if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                        lastOverlay.dismiss(undefined, BACKDROP);\n                    }\n                }\n            });\n        }\n    }\n};\nconst dismissOverlay = (doc, data, role, overlayTag, id) => {\n    const overlay = getPresentedOverlay(doc, overlayTag, id);\n    if (!overlay) {\n        return Promise.reject('overlay does not exist');\n    }\n    return overlay.dismiss(data, role);\n};\n/**\n * Returns a list of all overlays in the DOM even if they are not presented.\n */\nconst getOverlays = (doc, selector) => {\n    if (selector === undefined) {\n        selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover,ion-toast';\n    }\n    return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns a list of all presented overlays.\n * Inline overlays can exist in the DOM but not be presented,\n * so there are times when we want to exclude those.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n */\nconst getPresentedOverlays = (doc, overlayTag) => {\n    return getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n};\n/**\n * Returns a presented overlay element.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nconst getPresentedOverlay = (doc, overlayTag, id) => {\n    const overlays = getPresentedOverlays(doc, overlayTag);\n    return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nconst setRootAriaHidden = (hidden = false) => {\n    const root = getAppRoot(document);\n    const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n    if (!viewContainer) {\n        return;\n    }\n    if (hidden) {\n        viewContainer.setAttribute('aria-hidden', 'true');\n    }\n    else {\n        viewContainer.removeAttribute('aria-hidden');\n    }\n};\nconst present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n    var _a, _b;\n    if (overlay.presented) {\n        return;\n    }\n    setRootAriaHidden(true);\n    document.body.classList.add(BACKDROP_NO_SCROLL);\n    hideOverlaysFromScreenReaders(overlay.el);\n    overlay.presented = true;\n    overlay.willPresent.emit();\n    (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n    const mode = getIonMode(overlay);\n    // get the user's animation fn if one was provided\n    const animationBuilder = overlay.enterAnimation\n        ? overlay.enterAnimation\n        : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n    const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    if (completed) {\n        overlay.didPresent.emit();\n        (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n    }\n    /**\n     * When an overlay that steals focus\n     * is dismissed, focus should be returned\n     * to the element that was focused\n     * prior to the overlay opening. Toast\n     * does not steal focus and is excluded\n     * from returning focus as a result.\n     */\n    if (overlay.el.tagName !== 'ION-TOAST') {\n        restoreElementFocus(overlay.el);\n    }\n    /**\n     * If the focused element is already\n     * inside the overlay component then\n     * focus should not be moved from that\n     * to the overlay container.\n     */\n    if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n        overlay.el.focus();\n    }\n    /**\n     * If this overlay was previously dismissed without being\n     * the topmost one (such as by manually calling dismiss()),\n     * it would still have aria-hidden on being presented again.\n     * Removing it here ensures the overlay is visible to screen\n     * readers.\n     */\n    overlay.el.removeAttribute('aria-hidden');\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst restoreElementFocus = async (overlayEl) => {\n    let previousElement = document.activeElement;\n    if (!previousElement) {\n        return;\n    }\n    const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n    }\n    await overlayEl.onDidDismiss();\n    /**\n     * After onDidDismiss, the overlay loses focus\n     * because it is removed from the document\n     *\n     * > An element will also lose focus [...]\n     * > if the element is removed from the document)\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event\n     *\n     * Additionally, `document.activeElement` returns:\n     *\n     * > The Element which currently has focus,\n     * > `<body>` or null if there is\n     * > no focused element.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement#value\n     *\n     * However, if the user has already focused\n     * an element sometime between onWillDismiss\n     * and onDidDismiss (for example, focusing a\n     * text box after tapping a button in an\n     * action sheet) then don't restore focus to\n     * previous element\n     */\n    if (document.activeElement === null || document.activeElement === document.body) {\n        previousElement.focus();\n    }\n};\nconst dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n    var _a, _b;\n    if (!overlay.presented) {\n        return false;\n    }\n    const lastOverlay = doc !== undefined && getPresentedOverlays(doc).length === 1;\n    /**\n     * If this is the last visible overlay then\n     * we want to re-add the root to the accessibility tree.\n     */\n    if (lastOverlay) {\n        setRootAriaHidden(false);\n        document.body.classList.remove(BACKDROP_NO_SCROLL);\n    }\n    overlay.presented = false;\n    try {\n        // Overlay contents should not be clickable during dismiss\n        overlay.el.style.setProperty('pointer-events', 'none');\n        overlay.willDismiss.emit({ data, role });\n        (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n        const mode = getIonMode(overlay);\n        const animationBuilder = overlay.leaveAnimation\n            ? overlay.leaveAnimation\n            : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n        // If dismissed via gesture, no need to play leaving animation again\n        if (role !== GESTURE) {\n            await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n        }\n        overlay.didDismiss.emit({ data, role });\n        (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n        // Get a reference to all animations currently assigned to this overlay\n        // Then tear them down to return the overlay to its initial visual state\n        const animations = activeAnimations.get(overlay) || [];\n        animations.forEach((ani) => ani.destroy());\n        activeAnimations.delete(overlay);\n        /**\n         * Make overlay hidden again in case it is being reused.\n         * We can safely remove pointer-events: none as\n         * overlay-hidden will set display: none.\n         */\n        overlay.el.classList.add('overlay-hidden');\n        overlay.el.style.removeProperty('pointer-events');\n        /**\n         * Clear any focus trapping references\n         * when the overlay is dismissed.\n         */\n        if (overlay.el.lastFocus !== undefined) {\n            overlay.el.lastFocus = undefined;\n        }\n    }\n    catch (err) {\n        console.error(err);\n    }\n    overlay.el.remove();\n    revealOverlaysToScreenReaders();\n    return true;\n};\nconst getAppRoot = (doc) => {\n    return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n    // Make overlay visible in case it's hidden\n    baseEl.classList.remove('overlay-hidden');\n    const aniRoot = overlay.el;\n    const animation = animationBuilder(aniRoot, opts);\n    if (!overlay.animated || !config.getBoolean('animated', true)) {\n        animation.duration(0);\n    }\n    if (overlay.keyboardClose) {\n        animation.beforeAddWrite(() => {\n            const activeElement = baseEl.ownerDocument.activeElement;\n            if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n                activeElement.blur();\n            }\n        });\n    }\n    const activeAni = activeAnimations.get(overlay) || [];\n    activeAnimations.set(overlay, [...activeAni, animation]);\n    await animation.play();\n    return true;\n};\nconst eventMethod = (element, eventName) => {\n    let resolve;\n    const promise = new Promise((r) => (resolve = r));\n    onceEvent(element, eventName, (event) => {\n        resolve(event.detail);\n    });\n    return promise;\n};\nconst onceEvent = (element, eventName, callback) => {\n    const handler = (ev) => {\n        removeEventListener(element, eventName, handler);\n        callback(ev);\n    };\n    addEventListener(element, eventName, handler);\n};\nconst isCancel = (role) => {\n    return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nconst safeCall = (handler, arg) => {\n    if (typeof handler === 'function') {\n        const jmp = config.get('_zoneGate', defaultGate);\n        return jmp(() => {\n            try {\n                return handler(arg);\n            }\n            catch (e) {\n                throw e;\n            }\n        });\n    }\n    return undefined;\n};\nconst BACKDROP = 'backdrop';\nconst GESTURE = 'gesture';\nconst OVERLAY_GESTURE_PRIORITY = 39;\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nconst createDelegateController = (ref) => {\n    let inline = false;\n    let workingDelegate;\n    const coreDelegate = CoreDelegate();\n    /**\n     * Determines whether or not an overlay is being used\n     * inline or via a controller/JS and returns the correct delegate.\n     * By default, subsequent calls to getDelegate will use\n     * a cached version of the delegate.\n     * This is useful for calling dismiss after present,\n     * so that the correct delegate is given.\n     * @param force `true` to force the non-cached version of the delegate.\n     * @returns The delegate to use and whether or not the overlay is inline.\n     */\n    const getDelegate = (force = false) => {\n        if (workingDelegate && !force) {\n            return {\n                delegate: workingDelegate,\n                inline,\n            };\n        }\n        const { el, hasController, delegate } = ref;\n        /**\n         * If using overlay inline\n         * we potentially need to use the coreDelegate\n         * so that this works in vanilla JS apps.\n         * If a developer has presented this component\n         * via a controller, then we can assume\n         * the component is already in the\n         * correct place.\n         */\n        const parentEl = el.parentNode;\n        inline = parentEl !== null && !hasController;\n        workingDelegate = inline ? delegate || coreDelegate : delegate;\n        return { inline, delegate: workingDelegate };\n    };\n    /**\n     * Attaches a component in the DOM. Teleports the component\n     * to the root of the app.\n     * @param component The component to optionally construct and append to the element.\n     */\n    const attachViewToDom = async (component) => {\n        const { delegate } = getDelegate(true);\n        if (delegate) {\n            return await delegate.attachViewToDom(ref.el, component);\n        }\n        const { hasController } = ref;\n        if (hasController && component !== undefined) {\n            throw new Error('framework delegate is missing');\n        }\n        return null;\n    };\n    /**\n     * Moves a component back to its original location in the DOM.\n     */\n    const removeViewFromDom = () => {\n        const { delegate } = getDelegate();\n        if (delegate && ref.el !== undefined) {\n            delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n        }\n    };\n    return {\n        attachViewToDom,\n        removeViewFromDom,\n    };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nconst createTriggerController = () => {\n    let destroyTriggerInteraction;\n    /**\n     * Removes the click listener from the trigger element.\n     */\n    const removeClickListener = () => {\n        if (destroyTriggerInteraction) {\n            destroyTriggerInteraction();\n            destroyTriggerInteraction = undefined;\n        }\n    };\n    /**\n     * Adds a click listener to the trigger element.\n     * Presents the overlay when the trigger is clicked.\n     * @param el The overlay element.\n     * @param trigger The ID of the element to add a click listener to.\n     */\n    const addClickListener = (el, trigger) => {\n        removeClickListener();\n        const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n        if (!triggerEl) {\n            printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n            return;\n        }\n        const configureTriggerInteraction = (targetEl, overlayEl) => {\n            const openOverlay = () => {\n                overlayEl.present();\n            };\n            targetEl.addEventListener('click', openOverlay);\n            return () => {\n                targetEl.removeEventListener('click', openOverlay);\n            };\n        };\n        destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n    return {\n        addClickListener,\n        removeClickListener,\n    };\n};\n/**\n * Ensure that underlying overlays have aria-hidden if necessary so that screen readers\n * cannot move focus to these elements. Note that we cannot rely on focus/focusin/focusout\n * events here because those events do not fire when the screen readers moves to a non-focusable\n * element such as text.\n * Without this logic screen readers would be able to move focus outside of the top focus-trapped overlay.\n *\n * @param newTopMostOverlay - The overlay that is being presented. Since the overlay has not been\n * fully presented yet at the time this function is called it will not be included in the getPresentedOverlays result.\n */\nconst hideOverlaysFromScreenReaders = (newTopMostOverlay) => {\n    var _a;\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const presentedOverlay = overlays[i];\n        const nextPresentedOverlay = (_a = overlays[i + 1]) !== null && _a !== void 0 ? _a : newTopMostOverlay;\n        /**\n         * If next overlay has aria-hidden then all remaining overlays will have it too.\n         * Or, if the next overlay is a Toast that does not have aria-hidden then current overlay\n         * should not have aria-hidden either so focus can remain in the current overlay.\n         */\n        if (nextPresentedOverlay.hasAttribute('aria-hidden') || nextPresentedOverlay.tagName !== 'ION-TOAST') {\n            presentedOverlay.setAttribute('aria-hidden', 'true');\n        }\n    }\n};\n/**\n * When dismissing an overlay we need to reveal the new top-most overlay to screen readers.\n * If the top-most overlay is a Toast we potentially need to reveal more overlays since\n * focus is never automatically moved to the Toast.\n */\nconst revealOverlaysToScreenReaders = () => {\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const currentOverlay = overlays[i];\n        /**\n         * If the current we are looking at is a Toast then we can remove aria-hidden.\n         * However, we potentially need to keep looking at the overlay stack because there\n         * could be more Toasts underneath. Additionally, we need to unhide the closest non-Toast\n         * overlay too so focus can move there since focus is never automatically moved to the Toast.\n         */\n        currentOverlay.removeAttribute('aria-hidden');\n        /**\n         * If we found a non-Toast element then we can just remove aria-hidden and stop searching entirely\n         * since this overlay should always receive focus. As a result, all underlying overlays should still\n         * be hidden from screen readers.\n         */\n        if (currentOverlay.tagName !== 'ION-TOAST') {\n            break;\n        }\n    }\n};\nconst FOCUS_TRAP_DISABLE_CLASS = 'ion-disable-focus-trap';\n\nexport { BACKDROP as B, FOCUS_TRAP_DISABLE_CLASS as F, GESTURE as G, OVERLAY_GESTURE_PRIORITY as O, alertController as a, actionSheetController as b, popoverController as c, createDelegateController as d, createTriggerController as e, present as f, dismiss as g, eventMethod as h, isCancel as i, prepareOverlay as j, setOverlayId as k, loadingController as l, modalController as m, focusFirstDescendant as n, getPresentedOverlay as o, pickerController as p, focusLastDescendant as q, safeCall as s, toastController as t };\n", "/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nexport { getAssetPath, setAssetPath, setNonce, setPlatformOptions } from '@stencil/core/internal/client';\nexport { c as createAnimation } from './animation.js';\nexport { a as LIFECYCLE_DID_ENTER, c as LIFECYCLE_DID_LEAVE, L as LIFECYCLE_WILL_ENTER, b as LIFECYCLE_WILL_LEAVE, d as LIFECYCLE_WILL_UNLOAD, g as getIonPageElement } from './index2.js';\nexport { iosTransitionAnimation } from './ios.transition.js';\nexport { mdTransitionAnimation } from './md.transition.js';\nexport { g as getTimeGivenProgression } from './cubic-bezier.js';\nexport { createGesture } from './index3.js';\nexport { g as getPlatforms, i as initialize, a as isPlatform } from './ionic-global.js';\nexport { c as componentOnReady } from './helpers.js';\nexport { I as IonicSafeString, g as getMode, s as setupConfig } from './config.js';\nexport { o as openURL } from './theme.js';\nexport { m as menuController } from './index4.js';\nexport { b as actionSheetController, a as alertController, l as loadingController, m as modalController, p as pickerController, c as popoverController, t as toastController } from './overlays.js';\n\nconst IonicSlides = (opts) => {\n    const { swiper, extendParams } = opts;\n    const slidesParams = {\n        effect: undefined,\n        direction: 'horizontal',\n        initialSlide: 0,\n        loop: false,\n        parallax: false,\n        slidesPerView: 1,\n        spaceBetween: 0,\n        speed: 300,\n        slidesPerColumn: 1,\n        slidesPerColumnFill: 'column',\n        slidesPerGroup: 1,\n        centeredSlides: false,\n        slidesOffsetBefore: 0,\n        slidesOffsetAfter: 0,\n        touchEventsTarget: 'container',\n        freeMode: false,\n        freeModeMomentum: true,\n        freeModeMomentumRatio: 1,\n        freeModeMomentumBounce: true,\n        freeModeMomentumBounceRatio: 1,\n        freeModeMomentumVelocityRatio: 1,\n        freeModeSticky: false,\n        freeModeMinimumVelocity: 0.02,\n        autoHeight: false,\n        setWrapperSize: false,\n        zoom: {\n            maxRatio: 3,\n            minRatio: 1,\n            toggle: false,\n        },\n        touchRatio: 1,\n        touchAngle: 45,\n        simulateTouch: true,\n        touchStartPreventDefault: false,\n        shortSwipes: true,\n        longSwipes: true,\n        longSwipesRatio: 0.5,\n        longSwipesMs: 300,\n        followFinger: true,\n        threshold: 0,\n        touchMoveStopPropagation: true,\n        touchReleaseOnEdges: false,\n        iOSEdgeSwipeDetection: false,\n        iOSEdgeSwipeThreshold: 20,\n        resistance: true,\n        resistanceRatio: 0.85,\n        watchSlidesProgress: false,\n        watchSlidesVisibility: false,\n        preventClicks: true,\n        preventClicksPropagation: true,\n        slideToClickedSlide: false,\n        loopAdditionalSlides: 0,\n        noSwiping: true,\n        runCallbacksOnInit: true,\n        coverflowEffect: {\n            rotate: 50,\n            stretch: 0,\n            depth: 100,\n            modifier: 1,\n            slideShadows: true,\n        },\n        flipEffect: {\n            slideShadows: true,\n            limitRotation: true,\n        },\n        cubeEffect: {\n            slideShadows: true,\n            shadow: true,\n            shadowOffset: 20,\n            shadowScale: 0.94,\n        },\n        fadeEffect: {\n            crossFade: false,\n        },\n        a11y: {\n            prevSlideMessage: 'Previous slide',\n            nextSlideMessage: 'Next slide',\n            firstSlideMessage: 'This is the first slide',\n            lastSlideMessage: 'This is the last slide',\n        },\n    };\n    if (swiper.pagination) {\n        slidesParams.pagination = {\n            type: 'bullets',\n            clickable: false,\n            hideOnClick: false,\n        };\n    }\n    if (swiper.scrollbar) {\n        slidesParams.scrollbar = {\n            hide: true,\n        };\n    }\n    extendParams(slidesParams);\n};\n\nexport { IonicSlides };\n"],
  "mappings": "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",
  "names": ["config", "doc"]
}
